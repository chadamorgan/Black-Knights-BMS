<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Platoon Competition Manager</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for better aesthetics and responsiveness */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            color: #334155;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 1.5rem;
        }
        .card {
            background-color: #ffffff;
            border-radius: 0.75rem; /* rounded-xl */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); /* shadow-lg */
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }
        .btn {
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem; /* rounded-lg */
            font-weight: 600; /* font-semibold */
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        .btn-primary {
            background-color: #4f46e5; /* indigo-600 */
            color: #ffffff;
        }
        .btn-primary:hover {
            background-color: #4338ca; /* indigo-700 */
            transform: translateY(-1px);
        }
        .btn-secondary {
            background-color: #6b7280; /* gray-500 */
            color: #ffffff;
        }
        .btn-secondary:hover {
            background-color: #4b5563; /* gray-600 */
            transform: translateY(-1px);
        }
        .btn-danger {
            background-color: #ef4444; /* red-500 */
            color: #ffffff;
        }
        .btn-danger:hover {
            background-color: #dc2626; /* red-600 */
            transform: translateY(-1px);
        }
        input[type="number"],
        select {
            padding: 0.625rem 1rem;
            border-radius: 0.5rem;
            border: 1px solid #d1d5db; /* gray-300 */
            width: 100%;
            box-sizing: border-box;
            background-color: #f9fafb; /* gray-50 */
        }
        input[type="number"]:focus,
        select:focus {
            outline: none;
            border-color: #6366f1; /* indigo-500 */
            box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.2);
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
        }
        th, td {
            padding: 0.75rem 1rem;
            text-align: left;
            border-bottom: 1px solid #e5e7eb; /* gray-200 */
        }
        th {
            background-color: #f3f4f6; /* gray-100 */
            font-weight: 600;
            color: #4b5563;
        }
        tr:last-child td {
            border-bottom: none;
        }
        .grid-cols-1-md-2 {
            grid-template-columns: 1fr;
        }
        @media (min-width: 768px) {
            .grid-cols-1-md-2 {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        .platoon-score-row {
            font-weight: bold;
            background-color: #e0e7ff; /* indigo-100 */
            color: #312e81; /* indigo-900 */
        }
        .message-box {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #4CAF50; /* Green */
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }
        .message-box.show {
            opacity: 1;
        }
        .roadmap-platoon {
            background-color: #f8fafc; /* gray-50 */
            border-radius: 0.5rem;
            padding: 1rem;
            margin-bottom: 0.75rem;
            border: 1px solid #e2e8f0; /* gray-200 */
        }
        .roadmap-squad-status {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 9999px; /* full rounded */
            font-size: 0.75rem;
            font-weight: 500;
            margin-right: 0.5rem;
            margin-bottom: 0.25rem;
        }
        .status-not-started {
            background-color: #cbd5e1; /* gray-300 */
            color: #475569; /* gray-600 */
        }
        .status-part1-done {
            background-color: #bfdbfe; /* blue-200 */
            color: #1e40af; /* blue-800 */
        }
        .status-part2-done {
            background-color: #a7f3d0; /* emerald-200 */
            color: #065f46; /* emerald-800 */
        }
        .status-completed {
            background-color: #d1fae5; /* green-100 */
            color: #065f46; /* green-800 */
            font-weight: 700;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col">
    <div class="container py-8">
        <h1 class="text-4xl font-extrabold text-center text-indigo-800 mb-8">Black Knights BMS</h1>

        <!-- Message Box -->
        <div id="messageBox" class="message-box"></div>

        <!-- Competition Roadmap -->
        <div class="card">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Competition Roadmap</h2>
            <div id="roadmapContainer">
                <!-- Roadmap content will be populated by JS -->
                <p class="text-gray-600">Loading roadmap...</p>
            </div>
            <div class="mt-6 text-center">
                <button id="resetCompetitionBtn" class="btn btn-danger">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004 12m7-7h.582m7.418 0h.582m-6.418 0h.582m-6.418 0h.582m-6.418 0h.582M4 12a8.001 8.001 0 0015.356 2L20 10m-2.004 2.004L14.752 11.168A1 1 0 0110 13.82V10.18a1 1 0 011.555-.832l3.197 2.132a1 1 0 010 1.664z"></path></svg>
                    Reset Competition
                </button>
            </div>
        </div>

        <!-- Platoon and Squad Selection -->
        <div class="card">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Select Current Squad</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                    <label for="platoonSelect" class="block text-sm font-medium text-gray-700 mb-1">Platoon:</label>
                    <select id="platoonSelect" class="mt-1 block w-full">
                        <!-- Options will be populated by JS -->
                    </select>
                </div>
                <div>
                    <label for="squadSelect" class="block text-sm font-medium text-gray-700 mb-1">Squad:</label>
                    <select id="squadSelect" class="mt-1 block w-full">
                        <!-- Options will be populated by JS -->
                    </select>
                </div>
            </div>
            <div class="mt-6">
                <p class="text-lg font-semibold text-gray-700">Currently Managing: <span id="currentSquadDisplay" class="text-indigo-600">None Selected</span></p>
            </div>
        </div>

        <!-- Part 1: Equipment Move (Timed) -->
        <div class="card">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Part 1: Equipment Move</h2>
            <div class="flex flex-col md:flex-row items-center justify-between space-y-4 md:space-y-0 md:space-x-4 mb-6">
                <div class="text-4xl font-mono font-bold text-gray-900 bg-gray-50 p-4 rounded-lg shadow-inner w-full md:w-auto text-center">
                    <span id="timerDisplay">00:00:00</span>
                </div>
                <div class="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-2 w-full md:w-auto">
                    <button id="startTimerBtn" class="btn btn-primary w-full">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197 2.132A1 1 0 0110 13.82V10.18a1 1 0 011.555-.832l3.197 2.132a1 1 0 010 1.664z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                        Start Timer
                    </button>
                    <button id="stopTimerBtn" class="btn btn-secondary w-full" disabled>
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                        Stop Timer
                    </button>
                </div>
            </div>
            <button id="savePart1Btn" class="btn btn-primary w-full mt-4" disabled>
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                Save Part 1 Time
            </button>
        </div>

        <!-- Part 2: Firing Range -->
        <div class="card">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Part 2: Firing Range</h2>
            <div class="mb-4">
                <label for="numLanes" class="block text-sm font-medium text-gray-700 mb-1">Number of Firing Lanes:</label>
                <input type="number" id="numLanes" min="1" value="1" class="mt-1 block w-full">
            </div>
            <div id="laneScoresContainer" class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <!-- Lane score inputs will be generated here -->
            </div>
            <p class="text-lg font-semibold text-gray-700 mb-4">Average Targets Hit: <span id="averageTargetsDisplay" class="text-indigo-600">N/A</span></p>
            <div class="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-2">
                <button id="calculatePart2Btn" class="btn btn-secondary w-full">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 7h6m0 10v-3m-3 3h.01M9 17h.01M12 17h.01M7 17h.01M6 10h2m5-1a1 1 0 11-2 0 1 1 0 012 0zm3 0a1 1 0 11-2 0 1 1 0 012 0zM6 7h.01M6 13h.01L12 10l-6-3z"></path></svg>
                    Calculate Average
                </button>
                <button id="savePart2Btn" class="btn btn-primary w-full" disabled>
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                    Save Part 2 Score
                </button>
            </div>
        </div>

        <!-- Penalties -->
        <div class="card">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Apply Penalties</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <div>
                    <label for="penaltyTime" class="block text-sm font-medium text-gray-700 mb-1">Time Penalty (seconds):</label>
                    <input type="number" id="penaltyTime" min="0" value="0" class="mt-1 block w-full">
                </div>
                <div>
                    <label for="penaltyTargets" class="block text-sm font-medium text-gray-700 mb-1">Target Penalty (targets):</label>
                    <input type="number" id="penaltyTargets" min="0" value="0" class="mt-1 block w-full">
                </div>
            </div>
            <button id="applyPenaltiesBtn" class="btn btn-danger w-full">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path></svg>
                Apply Penalties
            </button>
        </div>

        <!-- Scoreboard -->
        <div class="card">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Live Scoreboard</h2>
            <div class="overflow-x-auto">
                <table id="scoreboardTable" class="min-w-full divide-y divide-gray-200">
                    <thead>
                        <tr>
                            <th class="px-6 py-3 bg-gray-50 text-left text-xs font-medium text-gray-500 uppercase tracking-wider rounded-tl-lg">Platoon</th>
                            <th class="px-6 py-3 bg-gray-50 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Squad</th>
                            <th class="px-6 py-3 bg-gray-50 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Part 1 Time (s)</th>
                            <th class="px-6 py-3 bg-gray-50 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Part 2 Targets</th>
                            <th class="px-6 py-3 bg-gray-50 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Time Penalty (s)</th>
                            <th class="px-6 py-3 bg-gray-50 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Target Penalty</th>
                            <th class="px-6 py-3 bg-gray-50 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Final Time (s)</th>
                            <th class="px-6 py-3 bg-gray-50 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Final Targets</th>
                            <th class="px-6 py-3 bg-gray-50 text-left text-xs font-medium text-gray-500 uppercase tracking-wider rounded-tr-lg">Score</th>
                        </tr>
                    </thead>
                    <tbody class="bg-white divide-y divide-gray-200">
                        <!-- Scoreboard rows will be populated by JS -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <script type="module">
        // Firebase SDKs
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, collection, query, getDocs, deleteDoc, getDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";


        // Data structure for the competition (initial state, will be overwritten by Firestore)
        const platoonsConfig = {
            "Crusaders": ["Squad 1", "Squad 2", "Squad 3", "Squad 4"],
            "Samurai": ["Squad 1", "Squad 2", "Squad 3", "Squad 4"],
            "Goonies": ["Squad 1", "Squad 2", "Squad 3", "Squad 4"],
            "Nightalkers": ["Squad 1", "Squad 2", "Squad 3", "Squad 4"]
        };

        // Global competition data state (will be populated from Firestore)
        let competitionData = {};

        // DOM Elements
        const platoonSelect = document.getElementById('platoonSelect');
        const squadSelect = document.getElementById('squadSelect');
        const currentSquadDisplay = document.getElementById('currentSquadDisplay');
        const timerDisplay = document.getElementById('timerDisplay');
        const startTimerBtn = document.getElementById('startTimerBtn');
        const stopTimerBtn = document.getElementById('stopTimerBtn');
        const savePart1Btn = document.getElementById('savePart1Btn');
        const numLanesInput = document.getElementById('numLanes');
        const laneScoresContainer = document.getElementById('laneScoresContainer');
        const averageTargetsDisplay = document.getElementById('averageTargetsDisplay');
        const calculatePart2Btn = document.getElementById('calculatePart2Btn');
        const savePart2Btn = document.getElementById('savePart2Btn');
        const penaltyTimeInput = document.getElementById('penaltyTime');
        const penaltyTargetsInput = document.getElementById('penaltyTargets');
        const applyPenaltiesBtn = document.getElementById('applyPenaltiesBtn');
        const scoreboardTableBody = document.querySelector('#scoreboardTable tbody');
        const messageBox = document.getElementById('messageBox');
        const roadmapContainer = document.getElementById('roadmapContainer');
        const resetCompetitionBtn = document.getElementById('resetCompetitionBtn');

        // Timer variables
        let timerInterval = null;
        let startTime = 0;
        let elapsedMilliseconds = 0;
        let currentSelectedPlatoon = null;
        let currentSelectedSquad = null;

        // Firebase references
        let db = null;
        let auth = null;
        let appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        let userId = null; // This will be the current user's ID
        let isAuthReady = false; // Flag to indicate if auth is ready

        // Initialize Firebase
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        try {
            const firebaseApp = initializeApp(firebaseConfig);
            db = getFirestore(firebaseApp);
            auth = getAuth(firebaseApp);

            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    userId = user.uid;
                    console.log("Authenticated user:", userId);
                } else {
                    // Sign in anonymously if no user is present
                    try {
                        if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                            await signInWithCustomToken(auth, __initial_auth_token);
                            userId = auth.currentUser.uid;
                            console.log("Signed in with custom token:", userId);
                        } else {
                            await signInAnonymously(auth);
                            userId = auth.currentUser.uid;
                            console.log("Signed in anonymously:", userId);
                        }
                    } catch (error) {
                        console.error("Firebase authentication error:", error);
                        // Fallback to a random ID if auth fails completely
                        userId = crypto.randomUUID();
                        console.warn("Using a random UUID as userId due to authentication failure.");
                    }
                }
                isAuthReady = true;
                // Once auth is ready, load competition data from Firestore
                loadCompetitionDataFromFirestore();
            });
        } catch (e) {
            console.error("Failed to initialize Firebase:", e);
            // Fallback to local data if Firebase initialization fails
            isAuthReady = true;
            userId = crypto.randomUUID(); // Still generate a random ID for consistency
            console.warn("Firebase initialization failed. The app will run without persistence.");
        }


        // Function to show messages
        function showMessage(message, type = 'info') {
            messageBox.textContent = message;
            messageBox.className = 'message-box show'; // Reset and show
            if (type === 'success') {
                messageBox.style.backgroundColor = '#4CAF50'; // Green
            } else if (type === 'error') {
                messageBox.style.backgroundColor = '#f44336'; // Red
            } else {
                messageBox.style.backgroundColor = '#2196F3'; // Blue
            }

            setTimeout(() => {
                messageBox.classList.remove('show');
            }, 3000); // Hide after 3 seconds
        }

        /**
         * Initializes the competition data in Firestore if it doesn't exist.
         * This creates the initial structure for platoons and squads.
         */
        async function initializeFirestoreData() {
            if (!db || !appId) {
                console.error("Firestore or appId not initialized.");
                return;
            }

            for (const platoonName in platoonsConfig) {
                const platoonDocRef = doc(db, `artifacts/${appId}/public/data/platoons`, platoonName);
                const platoonDocSnap = await getDoc(platoonDocRef);

                if (!platoonDocSnap.exists()) {
                    await setDoc(platoonDocRef, { platoonName: platoonName, platoonAverageScore: null });
                }

                for (const squadName of platoonsConfig[platoonName]) {
                    const squadDocRef = doc(db, `artifacts/${appId}/public/data/platoons/${platoonName}/squads`, squadName);
                    const squadDocSnap = await getDoc(squadDocRef);

                    if (!squadDocSnap.exists()) {
                        await setDoc(squadDocRef, {
                            platoonName: platoonName,
                            squadName: squadName,
                            part1Time: null,
                            part2Targets: null,
                            penaltyTime: 0,
                            penaltyTargets: 0,
                            status: "not started",
                            finalScore: null
                        });
                    }
                }
            }
            console.log("Firestore data initialization complete.");
        }

        /**
         * Loads competition data from Firestore and sets up real-time listeners.
         */
        async function loadCompetitionDataFromFirestore() {
            if (!isAuthReady || !db || !userId) {
                console.log("Auth not ready or Firebase not initialized. Retrying loadCompetitionDataFromFirestore...");
                setTimeout(loadCompetitionDataFromFirestore, 500); // Retry after 500ms
                return;
            }

            // Initialize data structure in Firestore if it's empty
            await initializeFirestoreData();

            // Set up real-time listener for platoons
            onSnapshot(collection(db, `artifacts/${appId}/public/data/platoons`), (platoonSnapshot) => {
                platoonSnapshot.docChanges().forEach(change => {
                    const platoonData = change.doc.data();
                    const platoonName = platoonData.platoonName;

                    if (!competitionData[platoonName]) {
                        competitionData[platoonName] = { squads: {} };
                    }
                    competitionData[platoonName].platoonAverageScore = platoonData.platoonAverageScore;

                    // Set up real-time listener for squads within this platoon
                    onSnapshot(collection(db, `artifacts/${appId}/public/data/platoons/${platoonName}/squads`), (squadSnapshot) => {
                        squadSnapshot.docChanges().forEach(squadChange => {
                            const squadData = squadChange.doc.data();
                            const squadName = squadData.squadName;
                            competitionData[platoonName].squads[squadName] = squadData;
                        });
                        // After all squad updates for a platoon, update UI
                        updateUI();
                    });
                });
                // Initial UI update after platoons are loaded
                updateUI();
            }, (error) => {
                console.error("Error listening to platoons:", error);
                showMessage("Failed to load competition data. Please check console.", "error");
            });
        }

        /**
         * Saves squad data to Firestore.
         * @param {string} platoonName
         * @param {string} squadName
         */
        async function saveSquadDataToFirestore(platoonName, squadName) {
            if (!db || !appId) {
                showMessage("Database not ready. Cannot save data.", "error");
                return;
            }
            const squadData = competitionData[platoonName].squads[squadName];
            try {
                const docRef = doc(db, `artifacts/${appId}/public/data/platoons/${platoonName}/squads`, squadName);
                await setDoc(docRef, squadData, { merge: true }); // Merge to update existing fields
                console.log(`Squad data saved to Firestore: ${platoonName} - ${squadName}`);
            } catch (e) {
                console.error("Error saving document: ", e);
                showMessage("Failed to save data to server. Please try again.", "error");
            }
        }

        /**
         * Resets all competition data in Firestore.
         */
        async function resetCompetition() {
            if (!db || !appId) {
                showMessage("Database not ready. Cannot reset data.", "error");
                return;
            }

            if (!confirm("Are you sure you want to reset all competition data? This action cannot be undone.")) {
                return;
            }

            try {
                // Delete all squad documents
                for (const platoonName in platoonsConfig) {
                    const squadsColRef = collection(db, `artifacts/${appId}/public/data/platoons/${platoonName}/squads`);
                    const squadDocs = await getDocs(squadsColRef);
                    for (const sDoc of squadDocs.docs) {
                        await deleteDoc(sDoc.ref);
                    }
                    // Delete platoon document itself
                    const platoonDocRef = doc(db, `artifacts/${appId}/public/data/platoons`, platoonName);
                    await deleteDoc(platoonDocRef);
                }

                // Re-initialize local and Firestore data to default state
                competitionData = {}; // Clear local state
                await initializeFirestoreData(); // Re-create initial structure in Firestore
                showMessage("Competition data reset successfully!", "success");
            } catch (e) {
                console.error("Error resetting competition data:", e);
                showMessage("Failed to reset competition data. Please check console.", "error");
            }
        }


        /**
         * Populates the platoon select dropdown.
         */
        function populatePlatoonSelect() {
            platoonSelect.innerHTML = '<option value="">-- Select Platoon --</option>';
            for (const platoonName in platoonsConfig) { // Use platoonsConfig for initial dropdown population
                const option = document.createElement('option');
                option.value = platoonName;
                option.textContent = platoonName;
                platoonSelect.appendChild(option);
            }
        }

        /**
         * Populates the squad select dropdown based on the selected platoon.
         */
        function populateSquadSelect() {
            squadSelect.innerHTML = '<option value="">-- Select Squad --</option>';
            const selectedPlatoon = platoonSelect.value;
            if (selectedPlatoon && platoonsConfig[selectedPlatoon]) { // Use platoonsConfig here too
                platoonsConfig[selectedPlatoon].forEach(squadName => {
                    const option = document.createElement('option');
                    option.value = squadName;
                    option.textContent = squadName;
                    squadSelect.appendChild(option);
                });
            }
            // Reset current squad selection if platoon changes
            currentSelectedSquad = null;
            updateCurrentSquadDisplay();
            resetPart1UI();
            resetPart2UI();
            resetPenaltiesUI();
        }

        /**
         * Updates the display for the currently selected squad.
         */
        function updateCurrentSquadDisplay() {
            if (currentSelectedPlatoon && currentSelectedSquad) {
                currentSquadDisplay.textContent = `${currentSelectedPlatoon} - ${currentSelectedSquad}`;
                // Load existing data for the selected squad into UI
                loadSquadDataForUI();
            } else {
                currentSquadDisplay.textContent = 'None Selected';
            }
            // Disable buttons if no squad is selected
            const isSquadSelected = currentSelectedPlatoon && currentSelectedSquad;
            startTimerBtn.disabled = !isSquadSelected;
            savePart1Btn.disabled = !isSquadSelected;
            calculatePart2Btn.disabled = !isSquadSelected;
            savePart2Btn.disabled = !isSquadSelected;
            applyPenaltiesBtn.disabled = !isSquadSelected;
        }

        /**
         * Loads the data of the currently selected squad into the UI elements.
         */
        function loadSquadDataForUI() {
            if (!currentSelectedPlatoon || !currentSelectedSquad || !competitionData[currentSelectedPlatoon] || !competitionData[currentSelectedPlatoon].squads[currentSelectedSquad]) return;

            const squadData = competitionData[currentSelectedPlatoon].squads[currentSelectedSquad];

            // Part 1 UI
            if (squadData.part1Time !== null) {
                timerDisplay.textContent = formatTime(squadData.part1Time * 1000);
                savePart1Btn.disabled = true; // Already saved
                startTimerBtn.disabled = true; // Cannot start again
                stopTimerBtn.disabled = true; // Cannot stop if not running
            } else {
                resetPart1UI();
            }

            // Part 2 UI (Note: Lane scores are not stored, only the average)
            if (squadData.part2Targets !== null) {
                averageTargetsDisplay.textContent = squadData.part2Targets.toFixed(2);
                savePart2Btn.disabled = true; // Already saved
            } else {
                averageTargetsDisplay.textContent = 'N/A';
                savePart2Btn.disabled = false; // Can save
            }
            generateLaneScoreInputs(); // Always generate inputs based on numLanes, even if data exists

            // Penalties UI
            penaltyTimeInput.value = squadData.penaltyTime;
            penaltyTargetsInput.value = squadData.penaltyTargets;
        }

        /**
         * Resets Part 1 UI elements to their initial state.
         */
        function resetPart1UI() {
            clearInterval(timerInterval);
            timerInterval = null;
            startTime = 0;
            elapsedMilliseconds = 0;
            timerDisplay.textContent = '00:00:00';
            startTimerBtn.disabled = false;
            stopTimerBtn.disabled = true;
            savePart1Btn.disabled = true;
        }

        /**
         * Resets Part 2 UI elements to their initial state.
         */
        function resetPart2UI() {
            averageTargetsDisplay.textContent = 'N/A';
            savePart2Btn.disabled = true;
            laneScoresContainer.innerHTML = ''; // Clear lane inputs
            numLanesInput.value = 1; // Reset to default 1 lane
            generateLaneScoreInputs(); // Regenerate for 1 lane
        }

        /**
         * Resets Penalties UI elements to their initial state.
         */
        function resetPenaltiesUI() {
            penaltyTimeInput.value = 0;
            penaltyTargetsInput.value = 0;
        }

        /**
         * Starts the timer for Part 1.
         */
        function startTimer() {
            if (!currentSelectedPlatoon || !currentSelectedSquad) {
                showMessage("Please select a platoon and squad first.", "error");
                return;
            }
            if (timerInterval) return; // Timer already running

            startTime = Date.now() - elapsedMilliseconds; // Resume from where it left off, or 0
            timerInterval = setInterval(updateTimer, 100); // Update every 100ms for smoother display

            startTimerBtn.disabled = true;
            stopTimerBtn.disabled = false;
            savePart1Btn.disabled = true; // Can't save while timer is running
            showMessage("Timer started!", "success");
        }

        /**
         * Updates the timer display.
         */
        function updateTimer() {
            elapsedMilliseconds = Date.now() - startTime;
            timerDisplay.textContent = formatTime(elapsedMilliseconds);
        }

        /**
         * Formats milliseconds into HH:MM:SS format.
         * @param {number} ms - Milliseconds to format.
         * @returns {string} Formatted time string.
         */
        function formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;

            const pad = (num) => num.toString().padStart(2, '0');
            return `${pad(hours)}:${pad(minutes)}:${pad(seconds)}`;
        }

        /**
         * Stops the timer and enables saving the time.
         */
        function stopTimer() {
            if (!timerInterval) return; // Timer not running

            clearInterval(timerInterval);
            timerInterval = null;

            startTimerBtn.disabled = false;
            stopTimerBtn.disabled = true;
            savePart1Btn.disabled = false;
            showMessage("Timer stopped. Save the time.", "info");
        }

        /**
         * Saves the recorded Part 1 time for the current squad.
         */
        async function savePart1Time() {
            if (!currentSelectedPlatoon || !currentSelectedSquad) {
                showMessage("Please select a platoon and squad first.", "error");
                return;
            }
            if (timerInterval) {
                showMessage("Please stop the timer before saving.", "error");
                return;
            }

            const squadData = competitionData[currentSelectedPlatoon].squads[currentSelectedSquad];
            squadData.part1Time = elapsedMilliseconds / 1000; // Store in seconds
            squadData.status = 'part1_done';
            savePart1Btn.disabled = true;
            await saveSquadDataToFirestore(currentSelectedPlatoon, currentSelectedSquad);
            showMessage(`Part 1 time saved for ${currentSelectedSquad}!`, "success");
        }

        /**
         * Generates input fields for firing lane scores based on the number of lanes.
         */
        function generateLaneScoreInputs() {
            const numLanes = parseInt(numLanesInput.value);
            laneScoresContainer.innerHTML = ''; // Clear previous inputs

            if (isNaN(numLanes) || numLanes < 1) {
                showMessage("Number of lanes must be at least 1.", "error");
                numLanesInput.value = 1; // Reset to 1
                return;
            }

            for (let i = 0; i < numLanes; i++) {
                const div = document.createElement('div');
                div.className = 'mb-2';
                div.innerHTML = `
                    <label for="lane${i + 1}" class="block text-sm font-medium text-gray-700 mb-1">Lane ${i + 1} Targets Hit (max 40):</label>
                    <input type="number" id="lane${i + 1}" min="0" max="40" value="0" class="mt-1 block w-full lane-score-input">
                `;
                laneScoresContainer.appendChild(div);
            }
            averageTargetsDisplay.textContent = 'N/A'; // Reset display when inputs change
            savePart2Btn.disabled = true; // Disable save until calculated
        }

        /**
         * Calculates the average targets hit for Part 2.
         */
        function calculatePart2Score() {
            if (!currentSelectedPlatoon || !currentSelectedSquad) {
                showMessage("Please select a platoon and squad first.", "error");
                return;
            }

            const laneInputs = document.querySelectorAll('.lane-score-input');
            if (laneInputs.length === 0) {
                showMessage("Please specify the number of firing lanes.", "error");
                return;
            }

            let totalTargets = 0;
            let validInputs = 0;
            let allInputsValid = true;
            laneInputs.forEach(input => {
                const targets = parseInt(input.value);
                if (!isNaN(targets) && targets >= 0 && targets <= 40) {
                    totalTargets += targets;
                    validInputs++;
                } else {
                    showMessage(`Invalid input for lane: ${input.id}. Targets must be between 0 and 40.`, "error");
                    allInputsValid = false;
                }
            });

            if (!allInputsValid) {
                averageTargetsDisplay.textContent = 'N/A';
                savePart2Btn.disabled = true;
                return; // Stop if any input was invalid
            }

            if (validInputs === 0) {
                averageTargetsDisplay.textContent = 'N/A';
                savePart2Btn.disabled = true;
                showMessage("No valid lane scores entered.", "error");
                return;
            }

            const averageTargets = totalTargets / validInputs;
            averageTargetsDisplay.textContent = averageTargets.toFixed(2);
            savePart2Btn.disabled = false; // Enable save after calculation
            showMessage("Average targets calculated. Click Save Part 2 Score.", "success");
        }

        /**
         * Saves the calculated Part 2 score for the current squad.
         */
        async function savePart2Score() {
            if (!currentSelectedPlatoon || !currentSelectedSquad) {
                showMessage("Please select a platoon and squad first.", "error");
                return;
            }
            if (averageTargetsDisplay.textContent === 'N/A') {
                showMessage("Please calculate the average targets hit first.", "error");
                return;
            }

            const squadData = competitionData[currentSelectedPlatoon].squads[currentSelectedSquad];
            squadData.part2Targets = parseFloat(averageTargetsDisplay.textContent);
            if (squadData.part1Time !== null) { // Check if Part 1 is done
                squadData.status = 'completed';
            } else {
                squadData.status = 'part2_done'; // If part1 not done yet
            }
            savePart2Btn.disabled = true;
            await saveSquadDataToFirestore(currentSelectedPlatoon, currentSelectedSquad);
            showMessage(`Part 2 score saved for ${currentSelectedSquad}!`, "success");
        }

        /**
         * Applies penalties to the current squad.
         */
        async function applyPenalties() {
            if (!currentSelectedPlatoon || !currentSelectedSquad) {
                showMessage("Please select a platoon and squad first.", "error");
                return;
            }

            const timePenalty = parseFloat(penaltyTimeInput.value);
            const targetPenalty = parseInt(penaltyTargetsInput.value);

            if (isNaN(timePenalty) || timePenalty < 0) {
                showMessage("Time penalty must be a non-negative number.", "error");
                return;
            }
            if (isNaN(targetPenalty) || targetPenalty < 0) {
                showMessage("Target penalty must be a non-negative integer.", "error");
                return;
            }

            const squadData = competitionData[currentSelectedPlatoon].squads[currentSelectedSquad];
            squadData.penaltyTime = timePenalty;
            squadData.penaltyTargets = targetPenalty;

            await saveSquadDataToFirestore(currentSelectedPlatoon, currentSelectedSquad);
            showMessage(`Penalties applied for ${currentSelectedSquad}!`, "success");
        }

        /**
         * Calculates the final score for a given squad.
         * Score = (Final Targets Hit) / (Final Time for Part 1)
         * @param {object} squadData - The squad data object.
         * @returns {number|string} The calculated score or 'N/A' if not complete.
         */
        function calculateFinalScore(squadData) {
            const finalPart1Time = (squadData.part1Time !== null ? squadData.part1Time : 0) + squadData.penaltyTime;
            const finalPart2Targets = (squadData.part2Targets !== null ? squadData.part2Targets : 0) - squadData.penaltyTargets;

            // Ensure targets don't go below zero
            const effectiveTargets = Math.max(0, finalPart2Targets);

            if (squadData.part1Time !== null && squadData.part2Targets !== null && finalPart1Time > 0) {
                squadData.finalScore = effectiveTargets / finalPart1Time;
                return squadData.finalScore.toFixed(4); // To 4 decimal places for precision
            }
            squadData.finalScore = null; // Reset if not complete
            return 'N/A';
        }

        /**
         * Updates the scoreboard table with current competition data.
         */
        function updateScoreboard() {
            scoreboardTableBody.innerHTML = ''; // Clear existing rows

            const allSquads = [];
            for (const platoonName in competitionData) {
                for (const squadName in competitionData[platoonName].squads) {
                    allSquads.push({ platoonName, squadName, data: competitionData[platoonName].squads[squadName] });
                }
            }

            // Sort squads by score (descending) for ranking, 'N/A' scores at the bottom
            allSquads.sort((a, b) => {
                const scoreA = parseFloat(calculateFinalScore(a.data));
                const scoreB = parseFloat(calculateFinalScore(b.data));

                if (isNaN(scoreA) && isNaN(scoreB)) return 0; // Both N/A, keep original order
                if (isNaN(scoreA)) return 1; // A is N/A, B is a number, A goes to bottom
                if (isNaN(scoreB)) return -1; // B is N/A, A is a number, B goes to bottom
                return scoreB - scoreA; // Sort descending
            });

            let currentPlatoon = null;
            for (const { platoonName, squadName, data } of allSquads) {
                // Add platoon average row if new platoon
                if (platoonName !== currentPlatoon) {
                    currentPlatoon = platoonName;
                    const platoonAvgRow = document.createElement('tr');
                    platoonAvgRow.className = 'platoon-score-row';
                    // Calculate platoon average
                    let totalPlatoonScore = 0;
                    let completedSquadsInPlatoon = 0;
                    for (const sName in competitionData[platoonName].squads) {
                        const score = parseFloat(calculateFinalScore(competitionData[platoonName].squads[sName]));
                        if (!isNaN(score)) {
                            totalPlatoonScore += score;
                            completedSquadsInPlatoon++;
                        }
                    }
                    const platoonAverage = completedSquadsInPlatoon > 0 ? (totalPlatoonScore / completedSquadsInPlatoon).toFixed(4) : 'N/A';

                    // Update platoon average in Firestore
                    if (db && appId) {
                        const platoonDocRef = doc(db, `artifacts/${appId}/public/data/platoons`, platoonName);
                        setDoc(platoonDocRef, { platoonAverageScore: platoonAverage }, { merge: true }).catch(e => console.error("Error updating platoon average:", e));
                    }


                    platoonAvgRow.innerHTML = `
                        <td class="px-6 py-3 text-lg font-bold" colspan="8">${platoonName} Average Score:</td>
                        <td class="px-6 py-3 text-lg font-bold">${platoonAverage}</td>
                    `;
                    scoreboardTableBody.appendChild(platoonAvgRow);
                }

                const row = document.createElement('tr');
                row.innerHTML = `
                    <td class="px-6 py-4 whitespace-nowrap">${platoonName}</td>
                    <td class="px-6 py-4 whitespace-nowrap">${squadName}</td>
                    <td class="px-6 py-4 whitespace-nowrap">${data.part1Time !== null ? data.part1Time.toFixed(2) : 'N/A'}</td>
                    <td class="px-6 py-4 whitespace-nowrap">${data.part2Targets !== null ? data.part2Targets.toFixed(2) : 'N/A'}</td>
                    <td class="px-6 py-4 whitespace-nowrap">${data.penaltyTime.toFixed(2)}</td>
                    <td class="px-6 py-4 whitespace-nowrap">${data.penaltyTargets}</td>
                    <td class="px-6 py-4 whitespace-nowrap">${(data.part1Time !== null ? (data.part1Time + data.penaltyTime).toFixed(2) : 'N/A')}</td>
                    <td class="px-6 py-4 whitespace-nowrap">${(data.part2Targets !== null ? Math.max(0, data.part2Targets - data.penaltyTargets).toFixed(2) : 'N/A')}</td>
                    <td class="px-6 py-4 whitespace-nowrap">${calculateFinalScore(data)}</td>
                `;
                scoreboardTableBody.appendChild(row);
            }
        }

        /**
         * Updates the roadmap display.
         */
        function updateRoadmap() {
            roadmapContainer.innerHTML = ''; // Clear existing roadmap

            for (const platoonName in platoonsConfig) {
                const platoonDiv = document.createElement('div');
                platoonDiv.className = 'roadmap-platoon';

                const platoonTitle = document.createElement('h3');
                platoonTitle.className = 'text-xl font-semibold text-gray-800 mb-2';
                platoonTitle.textContent = platoonName;
                platoonDiv.appendChild(platoonTitle);

                const squadStatusDiv = document.createElement('div');
                squadStatusDiv.className = 'flex flex-wrap gap-2';

                platoonsConfig[platoonName].forEach(squadName => {
                    const squadData = competitionData[platoonName]?.squads[squadName] || { status: "not started" };
                    const statusClass = `status-${squadData.status.replace(/_/g, '-')}`;

                    const squadSpan = document.createElement('span');
                    squadSpan.className = `roadmap-squad-status ${statusClass}`;
                    squadSpan.textContent = `${squadName}: ${squadData.status.replace(/_/g, ' ')}`;
                    squadStatusDiv.appendChild(squadSpan);
                });
                platoonDiv.appendChild(squadStatusDiv);
                roadmapContainer.appendChild(platoonDiv);
            }
        }

        /**
         * Central function to update all UI components.
         */
        function updateUI() {
            populatePlatoonSelect();
            populateSquadSelect();
            updateCurrentSquadDisplay();
            updateScoreboard();
            updateRoadmap();
        }


        // Event Listeners
        platoonSelect.addEventListener('change', populateSquadSelect);
        squadSelect.addEventListener('change', () => {
            currentSelectedPlatoon = platoonSelect.value;
            currentSelectedSquad = squadSelect.value;
            updateCurrentSquadDisplay();
        });
        startTimerBtn.addEventListener('click', startTimer);
        stopTimerBtn.addEventListener('click', stopTimer);
        savePart1Btn.addEventListener('click', savePart1Time);
        numLanesInput.addEventListener('change', generateLaneScoreInputs);
        calculatePart2Btn.addEventListener('click', calculatePart2Score);
        savePart2Btn.addEventListener('click', savePart2Score);
        applyPenaltiesBtn.addEventListener('click', applyPenalties);
        resetCompetitionBtn.addEventListener('click', resetCompetition);

        // Initial setup on page load
        document.addEventListener('DOMContentLoaded', () => {
            // Firebase authentication and data loading is handled by the script in the head.
            // The `updateUI` function will be called once data is loaded via `onSnapshot`.
            // Initial UI setup will be handled by the Firestore listeners.
        });
    </script>
</body>
</html>
