<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Black Knights BMS</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for Inter font and general aesthetics */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to top */
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }
        #app-container {
            background-color: #2d3748; /* Slightly lighter dark background for container */
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            width: 100%;
            max-width: 1200px;
            display: grid;
            grid-template-columns: 1fr;
            gap: 30px;
        }
        @media (min-width: 1024px) {
            #app-container {
                grid-template-columns: 2fr 1fr; /* Two columns on large screens */
            }
            #main-content {
                grid-column: 1;
            }
            #sidebar {
                grid-column: 2;
            }
        }
        h1, h2 {
            color: #63b3ed; /* A nice blue for headings */
            font-weight: 700;
        }
        .section-card {
            background-color: #4a5568; /* Card background */
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        .btn {
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .btn-primary {
            background-color: #63b3ed; /* Blue */
            color: #fff;
        }
        .btn-primary:hover {
            background-color: #4299e1;
            transform: translateY(-1px);
        }
        .btn-danger {
            background-color: #fc8181; /* Red */
            color: #fff;
        }
        .btn-danger:hover {
            background-color: #e53e3e;
            transform: translateY(-1px);
        }
        .btn-secondary {
            background-color: #a0aec0; /* Gray */
            color: #fff;
        }
        .btn-secondary:hover {
            background-color: #718096;
            transform: translateY(-1px);
        }
        input[type="number"], input[type="text"], select {
            background-color: #2d3748;
            border: 1px solid #4a5568;
            color: #e2e8f0;
            padding: 10px;
            border-radius: 8px;
            width: 100%;
            box-sizing: border-box;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #4a5568;
        }
        th {
            background-color: #4a5568;
            color: #fff;
            font-weight: 600;
        }
        tr:hover {
            background-color: #4a5568;
        }
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #2d3748;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            display: none; /* Hidden by default */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 15px;
            min-width: 300px;
            text-align: center;
        }
        .message-box p {
            font-size: 1.1em;
            color: #e2e8f0;
        }
        .message-box button {
            margin-top: 10px;
        }
        .message-box .confirm-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
    </style>
</head>
<body>
    <div id="app-container">
        <!-- Main Content Area -->
        <div id="main-content" class="space-y-8">
            <h1 class="text-4xl text-center mb-8">Black Knights BMS</h1>

            <!-- Message Box for alerts and confirmations -->
            <div id="messageBox" class="message-box">
                <p id="messageText"></p>
                <div id="confirmButtons" class="confirm-buttons" style="display: none;">
                    <button id="confirmYes" class="btn btn-danger">Yes</button>
                    <button id="confirmNo" class="btn btn-secondary">No</button>
                </div>
                <button id="closeMessageBox" class="btn btn-primary" style="display: none;">OK</button>
            </div>

            <!-- Platoon & Squad Selection -->
            <div class="section-card">
                <h2 class="text-2xl mb-4">Select Squad</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <label for="platoonSelect" class="block text-sm font-medium mb-1">Platoon:</label>
                        <select id="platoonSelect" class="mt-1 block w-full">
                            <option value="">Select Platoon</option>
                            <option value="Crusaders">Crusaders</option>
                            <option value="Samurai">Samurai</option>
                            <option value="Goonies">Goonies</option>
                            <option value="Nightsalkers">Nightsalkers</option>
                        </select>
                    </div>
                    <div>
                        <label for="squadSelect" class="block text-sm font-medium mb-1">Squad:</label>
                        <select id="squadSelect" class="mt-1 block w-full">
                            <option value="">Select Squad</option>
                            <!-- Squad options will be populated by JS -->
                        </select>
                    </div>
                </div>
            </div>

            <!-- Part 1: Equipment Move -->
            <div class="section-card">
                <h2 class="text-2xl mb-4">Part 1: Equipment Move (Timed)</h2>
                <div class="flex flex-col md:flex-row items-center justify-between gap-4 mb-4">
                    <div class="text-4xl font-mono" id="timerDisplay">00:00.00</div>
                    <div class="flex gap-2">
                        <button id="startTimerBtn" class="btn btn-primary">Start</button>
                        <button id="stopTimerBtn" class="btn btn-danger" disabled>Stop</button>
                        <button id="resetTimerBtn" class="btn btn-secondary" disabled>Reset</button>
                    </div>
                </div>
                <div class="mb-4">
                    <label for="manualTimeInput" class="block text-sm font-medium mb-1">Manual Time (seconds):</label>
                    <input type="number" id="manualTimeInput" class="mt-1 block w-full" placeholder="e.g., 120.5">
                </div>
                <button id="savePart1Btn" class="btn btn-primary w-full" disabled>Save Part 1 Score</button>
            </div>

            <!-- Part 2: Firing Range -->
            <div class="section-card">
                <h2 class="text-2xl mb-4">Part 2: Firing Range (Targets Hit)</h2>
                <div class="mb-4">
                    <label for="numLanesInput" class="block text-sm font-medium mb-1">Number of Firing Lanes:</label>
                    <input type="number" id="numLanesInput" class="mt-1 block w-full" min="1" value="1">
                </div>
                <div id="firingLaneInputs" class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                    <!-- Dynamic input fields for lanes will go here -->
                </div>
                <button id="calculatePart2Btn" class="btn btn-secondary w-full mb-2" disabled>Calculate Part 2 Score</button>
                <div class="text-lg font-bold text-right mb-4">Average Targets Hit: <span id="avgTargetsDisplay">0</span></div>
                <button id="savePart2Btn" class="btn btn-primary w-full" disabled>Save Part 2 Score</button>
            </div>

            <!-- Penalties -->
            <div class="section-card">
                <h2 class="text-2xl mb-4">Penalties</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                    <div>
                        <label for="timePenaltyInput" class="block text-sm font-medium mb-1">Time Penalty (seconds):</label>
                        <input type="number" id="timePenaltyInput" class="mt-1 block w-full" value="0">
                    </div>
                    <div>
                        <label for="targetPenaltyInput" class="block text-sm font-medium mb-1">Target Penalty (hits):</label>
                        <input type="number" id="targetPenaltyInput" class="mt-1 block w-full" value="0">
                    </div>
                </div>
                <button id="applyPenaltiesBtn" class="btn btn-danger w-full" disabled>Apply Penalties</button>
            </div>

            <!-- Admin Tools -->
            <div class="section-card">
                <h2 class="text-2xl mb-4">Admin Tools</h2>
                <button id="resetAllDataBtn" class="btn btn-danger w-full">Reset All Data</button>
            </div>
        </div>

        <!-- Sidebar for Scoreboard and Roadmap -->
        <div id="sidebar" class="space-y-8">
            <!-- Scoreboard -->
            <div class="section-card">
                <h2 class="text-2xl mb-4">Scoreboard</h2>
                <table id="scoreboardTable">
                    <thead>
                        <tr>
                            <th>Platoon</th>
                            <th>Avg. Score</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Scoreboard rows will be populated by JS -->
                    </tbody>
                </table>
            </div>

            <!-- Squad Performance Breakdown -->
            <div class="section-card">
                <h2 class="text-2xl mb-4">Squad Performance Breakdown</h2>
                <table id="squadPerformanceTable">
                    <thead>
                        <tr>
                            <th>Squad</th>
                            <th>Time (s)</th>
                            <th>Targets</th>
                            <th>Final Score</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Squad performance rows will be populated by JS -->
                    </tbody>
                </table>
            </div>

            <!-- Roadmap to Victory -->
            <div class="section-card">
                <h2 class="text-2xl mb-4">Roadmap to Victory</h2>
                <div id="roadmapContent" class="text-sm leading-relaxed space-y-2">
                    <p class="text-gray-400">Roadmap will appear here as squads complete their runs.</p>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        // Firebase SDK Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, collection, onSnapshot, getDocs, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Initialize Firebase variables (provided by Canvas environment)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // --- Firebase Initialization ---
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        let currentUserId = null; // To store the authenticated user's ID

        // --- Global Variables ---
        let squadsData = []; // Array to hold all squad data, synced with Firestore
        let currentSquadId = null; // ID of the currently selected squad
        let timerInterval;
        let startTime;
        let elapsedTime = 0; // Stores elapsed time in milliseconds

        // --- DOM Elements ---
        const platoonSelect = document.getElementById('platoonSelect');
        const squadSelect = document.getElementById('squadSelect');
        const timerDisplay = document.getElementById('timerDisplay');
        const startTimerBtn = document.getElementById('startTimerBtn');
        const stopTimerBtn = document.getElementById('stopTimerBtn');
        const resetTimerBtn = document.getElementById('resetTimerBtn');
        const manualTimeInput = document.getElementById('manualTimeInput');
        const savePart1Btn = document.getElementById('savePart1Btn');
        const numLanesInput = document.getElementById('numLanesInput');
        const firingLaneInputs = document.getElementById('firingLaneInputs');
        const calculatePart2Btn = document.getElementById('calculatePart2Btn');
        const avgTargetsDisplay = document.getElementById('avgTargetsDisplay');
        const savePart2Btn = document.getElementById('savePart2Btn');
        const timePenaltyInput = document.getElementById('timePenaltyInput');
        const targetPenaltyInput = document.getElementById('targetPenaltyInput');
        const applyPenaltiesBtn = document.getElementById('applyPenaltiesBtn');
        const scoreboardTableBody = document.querySelector('#scoreboardTable tbody');
        const squadPerformanceTableBody = document.querySelector('#squadPerformanceTable tbody');
        const roadmapContent = document.getElementById('roadmapContent');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const confirmButtons = document.getElementById('confirmButtons');
        const confirmYesBtn = document.getElementById('confirmYes');
        const confirmNoBtn = document.getElementById('confirmNo');
        const closeMessageBox = document.getElementById('closeMessageBox');
        const resetAllDataBtn = document.getElementById('resetAllDataBtn'); // New button

        // --- Utility Functions ---
        function formatTime(ms) {
            const totalSeconds = ms / 1000;
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = Math.floor(totalSeconds % 60);
            const milliseconds = Math.floor((totalSeconds - Math.floor(totalSeconds)) * 100);
            return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${String(milliseconds).padStart(2, '0')}`;
        }

        /**
         * Displays a message box. Can be used for simple alerts or confirmations.
         * @param {string} message The message to display.
         * @param {boolean} isConfirm If true, shows Yes/No buttons; otherwise, shows an OK button.
         * @returns {Promise<boolean>} Resolves to true for 'Yes', false for 'No' (only if isConfirm is true).
         */
        function showMessage(message, isConfirm = false) {
            messageText.textContent = message;
            if (isConfirm) {
                confirmButtons.style.display = 'flex';
                closeMessageBox.style.display = 'none';
            } else {
                confirmButtons.style.display = 'none';
                closeMessageBox.style.display = 'block';
            }
            messageBox.style.display = 'flex';

            return new Promise((resolve) => {
                const handleClose = () => {
                    messageBox.style.display = 'none';
                    closeMessageBox.removeEventListener('click', handleClose);
                    confirmYesBtn.removeEventListener('click', handleYes);
                    confirmNoBtn.removeEventListener('click', handleNo);
                };

                const handleYes = () => {
                    handleClose();
                    resolve(true);
                };

                const handleNo = () => {
                    handleClose();
                    resolve(false);
                };

                if (isConfirm) {
                    confirmYesBtn.addEventListener('click', handleYes);
                    confirmNoBtn.addEventListener('click', handleNo);
                } else {
                    closeMessageBox.addEventListener('click', handleClose);
                }
            });
        }

        // --- Firebase Data Operations ---

        /**
         * Initializes default squad data and saves it to Firestore if the collection is empty.
         * This ensures the app has initial data when first run.
         */
        async function initializeDefaultSquadsAndSave() {
            const platoons = ['Crusaders', 'Samurai', 'Goonies', 'Nightsalkers'];
            const initialSquads = [];
            platoons.forEach(platoon => {
                for (let i = 1; i <= 4; i++) {
                    initialSquads.push({
                        id: `${platoon}-Squad-${i}`,
                        platoon: platoon,
                        squad: `Squad ${i}`,
                        part1Time: null, // Time in seconds (raw)
                        part1Penalty: 0, // Additional time in seconds
                        part1ActualTime: null, // part1Time + part1Penalty
                        part2Targets: null, // Average targets hit (raw)
                        part2Penalty: 0, // Deducted targets
                        part2ActualTargets: null, // part2Targets - part2Penalty
                        finalScore: null, // (part2ActualTargets / part1ActualTime)
                        status: 'Not Started' // 'Not Started', 'Part 1 Complete', 'Part 2 Complete', 'Completed'
                    });
                }
            });

            console.log("Initializing default squads and saving to Firestore...");
            for (const squad of initialSquads) {
                try {
                    // Use the squad.id as the document ID for easy retrieval
                    const docRef = doc(db, `artifacts/${appId}/public/data/squads`, squad.id);
                    await setDoc(docRef, squad);
                } catch (e) {
                    console.error("Error adding initial squad document: ", e);
                    showMessage("Error initializing default squads. Check console for details.");
                }
            }
            console.log("Default squads initialized.");
            // The onSnapshot listener will automatically pick up these changes
        }

        /**
         * Sets up a real-time listener for squad data from Firestore.
         * Updates the global squadsData array and refreshes the UI.
         */
        function loadSquadsFromFirestore() {
            if (!db) {
                console.error("Firestore not initialized when trying to load data.");
                return;
            }

            const squadsCollectionRef = collection(db, `artifacts/${appId}/public/data/squads`);

            onSnapshot(squadsCollectionRef, (snapshot) => {
                const fetchedSquads = [];
                snapshot.forEach(doc => {
                    fetchedSquads.push(doc.data());
                });

                if (fetchedSquads.length === 0) {
                    // If no data in Firestore, initialize default squads and save them
                    initializeDefaultSquadsAndSave();
                } else {
                    squadsData = fetchedSquads;
                    console.log("Squads data loaded/updated from Firestore:", squadsData);
                    updateUIBasedOnData(); // Centralized UI update after data sync
                }
            }, (error) => {
                console.error("Error fetching squads from Firestore:", error);
                showMessage("Failed to load competition data. Please check your internet connection.");
            });
        }

        /**
         * Saves a single squad's data to Firestore.
         * @param {Object} squadToSave - The squad object to save.
         */
        async function saveSquadToFirestore(squadToSave) {
            if (!db || !currentUserId) { // Ensure Firebase and auth are ready
                console.error("Firestore or authentication not ready. Cannot save data.");
                showMessage("Database not ready. Please wait a moment or refresh.");
                return;
            }
            try {
                // Use the squad.id as the document ID
                const docRef = doc(db, `artifacts/${appId}/public/data/squads`, squadToSave.id);
                await setDoc(docRef, squadToSave); // setDoc will create or overwrite the document
                console.log("Squad document updated in Firestore:", squadToSave.id);
                // No need to call updateUI here, onSnapshot will handle it.
            } catch (e) {
                console.error("Error updating document in Firestore: ", e);
                showMessage("Failed to save data. Please try again.");
            }
        }

        // --- Centralized UI Update Function ---
        /**
         * Calls all UI update functions after data has been loaded or changed.
         */
        function updateUIBasedOnData() {
            populateSquadsDropdown(); // Re-populate dropdown to reflect any new/changed squads
            updateUIForSelectedSquad();
            updateScoreboard();
            updateSquadPerformance();
            generateRoadmap();
        }

        // --- Squad Selection Logic ---
        function populateSquadsDropdown() {
            const selectedPlatoon = platoonSelect.value;
            squadSelect.innerHTML = '<option value="">Select Squad</option>';
            if (selectedPlatoon) {
                const squadsInPlatoon = squadsData.filter(s => s.platoon === selectedPlatoon);
                squadsInPlatoon.forEach(squad => {
                    const option = document.createElement('option');
                    option.value = squad.id;
                    option.textContent = squad.squad;
                    squadSelect.appendChild(option);
                });
            }
            // If currentSquadId is not in the new list, reset it
            if (currentSquadId && !squadsData.some(s => s.id === currentSquadId)) {
                currentSquadId = null;
                squadSelect.value = ""; // Clear dropdown selection
            } else if (currentSquadId) {
                squadSelect.value = currentSquadId; // Keep selection if still valid
            }
            updateUIForSelectedSquad(); // Update UI after dropdown is populated
        }

        function updateUIForSelectedSquad() {
            const selectedSquad = squadsData.find(s => s.id === currentSquadId);

            // Enable/disable buttons based on squad selection
            const isSquadSelected = currentSquadId !== null;
            savePart1Btn.disabled = !isSquadSelected;
            calculatePart2Btn.disabled = !isSquadSelected;
            savePart2Btn.disabled = !isSquadSelected;
            applyPenaltiesBtn.disabled = !isSquadSelected;

            if (selectedSquad) {
                // Update Part 1 UI
                if (selectedSquad.part1Time !== null) {
                    timerDisplay.textContent = formatTime(selectedSquad.part1Time * 1000);
                    manualTimeInput.value = selectedSquad.part1Time;
                    startTimerBtn.disabled = true;
                    stopTimerBtn.disabled = true;
                    resetTimerBtn.disabled = false;
                } else {
                    timerDisplay.textContent = '00:00.00';
                    manualTimeInput.value = '';
                    startTimerBtn.disabled = false;
                    stopTimerBtn.disabled = true;
                    resetTimerBtn.disabled = true;
                }

                // Update Part 2 UI
                if (selectedSquad.part2Targets !== null) {
                    avgTargetsDisplay.textContent = selectedSquad.part2Targets.toFixed(2);
                } else {
                    avgTargetsDisplay.textContent = '0';
                }
                populateFiringLaneInputs(); // Ensure lane inputs are generated (values are reset on selection)

                // Update Penalties UI
                timePenaltyInput.value = selectedSquad.part1Penalty;
                targetPenaltyInput.value = selectedSquad.part2Penalty;

            } else {
                // Reset all UI elements if no squad is selected
                timerDisplay.textContent = '00:00.00';
                manualTimeInput.value = '';
                numLanesInput.value = '1';
                firingLaneInputs.innerHTML = '';
                avgTargetsDisplay.textContent = '0';
                timePenaltyInput.value = '0';
                targetPenaltyInput.value = '0';
                clearInterval(timerInterval);
                startTimerBtn.disabled = false;
                stopTimerBtn.disabled = true;
                resetTimerBtn.disabled = true;
            }
        }

        platoonSelect.addEventListener('change', populateSquadsDropdown);
        squadSelect.addEventListener('change', () => {
            currentSquadId = squadSelect.value;
            updateUIForSelectedSquad();
        });

        // --- Part 1: Equipment Move Timer Logic ---
        startTimerBtn.addEventListener('click', () => {
            if (!currentSquadId) {
                showMessage('Please select a squad first.');
                return;
            }
            startTime = Date.now() - elapsedTime;
            timerInterval = setInterval(updateTimer, 10); // Update every 10ms for hundredths
            startTimerBtn.disabled = true;
            stopTimerBtn.disabled = false;
            resetTimerBtn.disabled = false;
        });

        stopTimerBtn.addEventListener('click', () => {
            clearInterval(timerInterval);
            startTimerBtn.disabled = false;
            stopTimerBtn.disabled = true;
            // elapsedTime is already updated by updateTimer
        });

        resetTimerBtn.addEventListener('click', () => {
            clearInterval(timerInterval);
            elapsedTime = 0;
            timerDisplay.textContent = '00:00.00';
            startTimerBtn.disabled = false;
            stopTimerBtn.disabled = true;
            resetTimerBtn.disabled = true;
        });

        function updateTimer() {
            elapsedTime = Date.now() - startTime;
            timerDisplay.textContent = formatTime(elapsedTime);
        }

        savePart1Btn.addEventListener('click', async () => {
            if (!currentSquadId) {
                showMessage('Please select a squad first.');
                return;
            }
            let timeToSave = parseFloat(manualTimeInput.value);
            if (isNaN(timeToSave) || timeToSave <= 0) {
                timeToSave = elapsedTime / 1000; // Use timer value if manual is invalid
            }

            if (timeToSave <= 0) {
                showMessage('Please enter a valid positive time or use the timer.');
                return;
            }

            const squad = squadsData.find(s => s.id === currentSquadId);
            if (squad) {
                squad.part1Time = timeToSave;
                squad.part1ActualTime = squad.part1Time + squad.part1Penalty;
                if (squad.status === 'Not Started') {
                    squad.status = 'Part 1 Complete';
                }
                calculateAndSaveFinalScore(squad); // Updates squad.finalScore and status
                await saveSquadToFirestore(squad); // Save to Firestore
                showMessage(`Part 1 score saved for ${squad.id}: ${formatTime(squad.part1Time * 1000)}`);
            }
        });

        // --- Part 2: Firing Range Logic ---
        numLanesInput.addEventListener('input', populateFiringLaneInputs);

        function populateFiringLaneInputs() {
            const numLanes = parseInt(numLanesInput.value);
            firingLaneInputs.innerHTML = ''; // Clear previous inputs

            if (isNaN(numLanes) || numLanes < 1) {
                numLanesInput.value = 1; // Default to 1 if invalid
                return;
            }

            for (let i = 1; i <= numLanes; i++) {
                const div = document.createElement('div');
                div.innerHTML = `
                    <label for="lane${i}" class="block text-sm font-medium mb-1">Lane ${i} Targets Hit (Max 40):</label>
                    <input type="number" id="lane${i}" class="mt-1 block w-full lane-score-input" min="0" max="40" value="0">
                `;
                firingLaneInputs.appendChild(div);
            }
        }

        calculatePart2Btn.addEventListener('click', () => {
            if (!currentSquadId) {
                showMessage('Please select a squad first.');
                return;
            }
            const laneInputs = document.querySelectorAll('.lane-score-input');
            let totalTargets = 0;
            let validLanes = 0;

            laneInputs.forEach(input => {
                const targets = parseInt(input.value);
                if (!isNaN(targets) && targets >= 0 && targets <= 40) {
                    totalTargets += targets;
                    validLanes++;
                }
            });

            if (validLanes === 0) {
                avgTargetsDisplay.textContent = '0';
                showMessage('No valid lane scores entered.');
                return;
            }

            const averageTargets = totalTargets / validLanes;
            avgTargetsDisplay.textContent = averageTargets.toFixed(2);
        });

        savePart2Btn.addEventListener('click', async () => {
            if (!currentSquadId) {
                showMessage('Please select a squad first.');
                return;
            }
            const squad = squadsData.find(s => s.id === currentSquadId);
            if (squad) {
                const currentAvgTargets = parseFloat(avgTargetsDisplay.textContent);
                if (isNaN(currentAvgTargets)) {
                    showMessage('Please calculate the Part 2 score first.');
                    return;
                }
                squad.part2Targets = currentAvgTargets;
                squad.part2ActualTargets = squad.part2Targets - squad.part2Penalty;
                if (squad.status === 'Part 1 Complete' || squad.status === 'Not Started') {
                    squad.status = 'Part 2 Complete';
                }
                if (squad.part1Time !== null && squad.part2Targets !== null) {
                    squad.status = 'Completed';
                }
                calculateAndSaveFinalScore(squad); // Updates squad.finalScore and status
                await saveSquadToFirestore(squad); // Save to Firestore
                showMessage(`Part 2 score saved for ${squad.id}: ${squad.part2Targets.toFixed(2)} average targets.`);
            }
        });

        // --- Penalties Logic ---
        applyPenaltiesBtn.addEventListener('click', async () => {
            if (!currentSquadId) {
                showMessage('Please select a squad first.');
                return;
            }
            const squad = squadsData.find(s => s.id === currentSquadId);
            if (squad) {
                const timePenalty = parseFloat(timePenaltyInput.value) || 0;
                const targetPenalty = parseFloat(targetPenaltyInput.value) || 0;

                squad.part1Penalty = timePenalty;
                squad.part2Penalty = targetPenalty;

                // Recalculate actual scores with penalties
                if (squad.part1Time !== null) {
                    squad.part1ActualTime = squad.part1Time + squad.part1Penalty;
                }
                if (squad.part2Targets !== null) {
                    squad.part2ActualTargets = squad.part2Targets - squad.part2Penalty;
                }

                calculateAndSaveFinalScore(squad); // Updates squad.finalScore and status
                await saveSquadToFirestore(squad); // Save to Firestore
                showMessage(`Penalties applied for ${squad.id}.`);
            }
        });

        // --- Score Calculation ---
        function calculateAndSaveFinalScore(squad) {
            if (squad.part1ActualTime !== null && squad.part2ActualTargets !== null) {
                // Ensure time is not zero to avoid division by zero
                if (squad.part1ActualTime > 0) {
                    squad.finalScore = squad.part2ActualTargets / squad.part1ActualTime;
                } else {
                    squad.finalScore = 0; // Or handle as an error/infinite score
                }
                squad.status = 'Completed';
            } else {
                squad.finalScore = null;
            }
        }

        // --- Scoreboard Update ---
        function updateScoreboard() {
            const platoonScores = {}; // { PlatoonName: { totalScore: 0, completedSquads: 0, totalSquads: 4 } }

            // Initialize platoon scores
            ['Crusaders', 'Samurai', 'Goonies', 'Nightsalkers'].forEach(platoon => {
                platoonScores[platoon] = { totalScore: 0, completedSquads: 0, totalSquads: 4, averageScore: 0 };
            });

            squadsData.forEach(squad => {
                if (squad.status === 'Completed' && squad.finalScore !== null) {
                    platoonScores[squad.platoon].totalScore += squad.finalScore;
                    platoonScores[squad.platoon].completedSquads++;
                }
            });

            // Calculate average scores and sort
            const sortedPlatoons = Object.keys(platoonScores).map(platoonName => {
                const platoon = platoonScores[platoonName];
                platoon.averageScore = platoon.completedSquads > 0 ? platoon.totalScore / platoon.completedSquads : 0;
                return {
                    platoon: platoonName,
                    averageScore: platoon.averageScore,
                    completedSquads: platoon.completedSquads
                };
            }).sort((a, b) => b.averageScore - a.averageScore); // Sort descending

            // Populate scoreboard table
            scoreboardTableBody.innerHTML = '';
            sortedPlatoons.forEach(platoon => {
                const row = scoreboardTableBody.insertRow();
                row.innerHTML = `
                    <td class="font-bold">${platoon.platoon}</td>
                    <td>${platoon.averageScore.toFixed(4)}</td>
                `;
            });
        }

        // --- Squad Performance Breakdown Update ---
        function updateSquadPerformance() {
            squadPerformanceTableBody.innerHTML = ''; // Clear previous rows

            // Sort squads by platoon then by squad number for consistent display
            const sortedSquads = [...squadsData].sort((a, b) => {
                if (a.platoon < b.platoon) return -1;
                if (a.platoon > b.platoon) return 1;
                // If platoons are the same, sort by squad number (e.g., "Squad 1" before "Squad 2")
                const squadNumA = parseInt(a.squad.replace('Squad ', ''));
                const squadNumB = parseInt(b.squad.replace('Squad ', ''));
                return squadNumA - squadNumB;
            });

            sortedSquads.forEach(squad => {
                const row = squadPerformanceTableBody.insertRow();
                const part1TimeDisplay = squad.part1ActualTime !== null ? squad.part1ActualTime.toFixed(2) + 's' : 'N/A';
                const part2TargetsDisplay = squad.part2ActualTargets !== null ? squad.part2ActualTargets.toFixed(2) : 'N/A';
                const finalScoreDisplay = squad.finalScore !== null ? squad.finalScore.toFixed(4) : 'N/A';

                row.innerHTML = `
                    <td class="font-bold">${squad.platoon} ${squad.squad}</td>
                    <td>${part1TimeDisplay}</td>
                    <td>${part2TargetsDisplay}</td>
                    <td>${finalScoreDisplay}</td>
                    <td>${squad.status}</td>
                `;
            });
        }


        // --- Roadmap to Victory Logic ---
        function generateRoadmap() {
            roadmapContent.innerHTML = ''; // Clear previous roadmap

            const platoonStatus = {}; // { PlatoonName: { completedSquads: [], pendingSquads: [], avgScore: 0 } }

            // Group squads by platoon and status
            ['Crusaders', 'Samurai', 'Goonies', 'Nightsalkers'].forEach(platoonName => {
                platoonStatus[platoonName] = {
                    completedSquads: [],
                    pendingSquads: [],
                    avgScore: 0,
                    totalScoreSum: 0,
                    totalSquads: 4
                };
                squadsData.filter(s => s.platoon === platoonName).forEach(squad => {
                    if (squad.status === 'Completed' && squad.finalScore !== null) {
                        platoonStatus[platoonName].completedSquads.push(squad);
                        platoonStatus[platoonName].totalScoreSum += squad.finalScore;
                    } else {
                        platoonStatus[platoonName].pendingSquads.push(squad);
                    }
                });
                platoonStatus[platoonName].avgScore = platoonStatus[platoonName].completedSquads.length > 0 ?
                    platoonStatus[platoonName].totalScoreSum / platoonStatus[platoonName].completedSquads.length : 0;
            });

            // Sort platoons by current average score
            const sortedPlatoons = Object.keys(platoonStatus)
                .map(platoonName => ({
                    name: platoonName,
                    ...platoonStatus[platoonName]
                }))
                .sort((a, b) => b.avgScore - a.avgScore);

            if (sortedPlatoons.length === 0) {
                roadmapContent.innerHTML = '<p class="text-gray-400">Roadmap will appear here as squads complete their runs.</p>';
                return;
            }

            const currentLeader = sortedPlatoons[0];
            const leaderScore = currentLeader.avgScore;

            if (currentLeader.completedSquads.length === 0) {
                 roadmapContent.innerHTML = '<p class="text-gray-400">No scores yet. Start completing runs to see the roadmap!</p>';
                 return;
            }

            const header = document.createElement('p');
            header.className = 'font-bold text-lg text-blue-300';
            header.textContent = `Current Leader: ${currentLeader.name} (Avg. Score: ${leaderScore.toFixed(4)})`;
            roadmapContent.appendChild(header);

            sortedPlatoons.forEach(platoon => {
                if (platoon.name === currentLeader.name && platoon.completedSquads.length === platoon.totalSquads) {
                    const p = document.createElement('p');
                    p.innerHTML = `<span class="font-semibold">${platoon.name}:</span> All squads completed! Maintain your lead.`;
                    roadmapContent.appendChild(p);
                    return;
                }

                const p = document.createElement('p');
                p.className = 'mt-2';
                let message = `<span class="font-semibold">${platoon.name}:</span> `;

                if (platoon.completedSquads.length === platoon.totalSquads) {
                    message += `All squads completed with an average score of ${platoon.avgScore.toFixed(4)}. You need higher scores from your completed runs to compete.`;
                } else {
                    const remainingSquadsCount = platoon.pendingSquads.length;
                    const completedSquadsCount = platoon.completedSquads.length;

                    // Calculate the total score needed for this platoon to surpass the leader
                    // Let S_L = leader's average score
                    // Let S_P = this platoon's current average score
                    // Let N_C = number of completed squads for this platoon
                    // Let N_R = number of remaining squads for this platoon
                    // Let S_R_avg = average score needed for remaining squads
                    // Target total score for platoon: (S_L * totalSquads) + epsilon (a small margin to win)
                    // Current total score sum: platoon.totalScoreSum
                    // Needed sum from remaining squads: (S_L * totalSquads) - platoon.totalScoreSum + epsilon
                    // S_R_avg = ( (S_L * totalSquads) - platoon.totalScoreSum + epsilon ) / N_R

                    const epsilon = 0.0001; // Small margin to ensure they "win"
                    let targetTotalScoreForPlatoon = (leaderScore * platoon.totalSquads) + epsilon;
                    let neededScoreFromRemainingSquadsSum = targetTotalScoreForPlatoon - platoon.totalScoreSum;

                    if (neededScoreFromRemainingSquadsSum < 0) { // Already ahead or tied, but not all squads done
                        message += `Currently ahead or tied with the leader (${platoon.avgScore.toFixed(4)}). Keep up the great work with your ${remainingSquadsCount} remaining squads!`;
                    } else if (remainingSquadsCount > 0) {
                        const neededAvgScorePerRemainingSquad = neededScoreFromRemainingSquadsSum / remainingSquadsCount;

                        message += `To take the lead, your ${remainingSquadsCount} remaining squads need to average at least <span class="text-green-300 font-bold">${neededAvgScorePerRemainingSquad.toFixed(4)}</span> per squad.`;

                        // Provide actionable advice:
                        // Assuming average targets hit is around 20-30 and time is 60-120 seconds for a "good" score.
                        // If score = Targets / Time
                        // To get neededAvgScorePerRemainingSquad, they could aim for:
                        // Option 1: A specific time with a good targets score (e.g., 30 targets)
                        // Time = Targets / Score
                        const suggestedTargets = 30; // Example good target score
                        const suggestedTime = suggestedTargets / neededAvgScorePerRemainingSquad;

                        // Option 2: A specific targets score with a good time (e.g., 90 seconds)
                        // Targets = Score * Time
                        const suggestedTimeForTargets = 90; // Example good time
                        const suggestedTargetsForTime = neededAvgScorePerRemainingSquad * suggestedTimeForTargets;

                        message += `<br>This could mean:`;
                        if (suggestedTime > 0 && suggestedTargetsForTime <= 40) { // Check if targets are realistic
                            message += ` <span class="text-yellow-300">- Averaging ${suggestedTargets} targets in approximately ${suggestedTime.toFixed(1)} seconds (Part 1).</span>`;
                        }
                        if (suggestedTargetsForTime > 0 && suggestedTargetsForTime <= 40) {
                            message += `<br> <span class="text-yellow-300">- Averaging ${suggestedTargetsForTime.toFixed(1)} targets while completing Part 1 in ${suggestedTimeForTargets.toFixed(1)} seconds.</span>`;
                        } else {
                            message += `<br> <span class="text-yellow-300">- Focus on maximizing targets hit and minimizing time for the best possible combined score.</span>`;
                        }

                    } else {
                        // No remaining squads, and not in the lead
                        message += `All squads completed with an average score of ${platoon.avgScore.toFixed(4)}. You need higher scores from your completed runs to compete.`;
                    }
                }
                p.innerHTML = message;
                roadmapContent.appendChild(p);
            });
        }

        // --- Reset All Data Functionality ---
        resetAllDataBtn.addEventListener('click', async () => {
            const confirmed = await showMessage(
                'Are you sure you want to reset all competition data? This action cannot be undone.',
                true // isConfirm = true
            );

            if (confirmed) {
                if (!db || !currentUserId) {
                    showMessage("Database not ready. Cannot reset data.");
                    return;
                }

                try {
                    showMessage("Resetting all data... Please wait.");
                    const squadsCollectionRef = collection(db, `artifacts/${appId}/public/data/squads`);
                    const querySnapshot = await getDocs(squadsCollectionRef);

                    const deletePromises = [];
                    querySnapshot.forEach((doc) => {
                        deletePromises.push(deleteDoc(doc.ref));
                    });

                    await Promise.all(deletePromises);
                    console.log("All squad documents deleted from Firestore.");

                    // After deleting, re-initialize default squads
                    await initializeDefaultSquadsAndSave();
                    showMessage("All competition data has been reset and default squads re-initialized.");

                    // Reset UI elements that might not be covered by onSnapshot's updateUIBasedOnData
                    currentSquadId = null;
                    platoonSelect.value = "";
                    squadSelect.innerHTML = '<option value="">Select Squad</option>';
                    updateUIForSelectedSquad(); // This will reset many fields
                    timerDisplay.textContent = '00:00.00';
                    elapsedTime = 0;
                    clearInterval(timerInterval);

                } catch (error) {
                    console.error("Error resetting data:", error);
                    showMessage("Failed to reset data. Please check console for details.");
                }
            } else {
                showMessage("Data reset cancelled.");
            }
        });


        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            // Authenticate and then load data
            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    currentUserId = user.uid;
                    console.log("Authenticated as:", currentUserId);
                    loadSquadsFromFirestore(); // Start listening for data
                } else {
                    // Sign in anonymously if no user is found
                    try {
                        if (initialAuthToken) {
                            await signInWithCustomToken(auth, initialAuthToken);
                        } else {
                            await signInAnonymously(auth);
                        }
                    } catch (error) {
                        console.error("Firebase authentication error:", error);
                        showMessage("Authentication failed. Please try refreshing the page.");
                    }
                }
            });
        });
    </script>
</body>
</html>
